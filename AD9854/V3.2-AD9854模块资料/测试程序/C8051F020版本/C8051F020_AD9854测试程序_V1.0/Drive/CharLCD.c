//-----------------------------------------------------------------
// 程序描述:
//     HD44780(KS0066U)内核的字符型LCM子程序
// 作    者: 凌智电子
// 开始日期: 2009-11-28
// 完成日期: 2009-11-28
// 修改日期:
// 版    本: V4.2:在V3版本上修改LCM使能信号的延时时间
// 调试工具: C8051F02xTBC;1602字符型液晶显示模块(LCM)
// 说    明:
//     (1)调试使用的系统时钟频率Fsysclk=22.1184MHz;
//     (2)LCM的接口方式:间接控制方式;
//     (3)LCM的数据线(14-11脚)和控制线可以和单片机的任意I/O口相连,使程序更具
//        通用性,且因它们均外接上拉电阻,需要在单片机配置中设置为推挽方式,如:
//        P3MDOUT = 0xf0;                     // 数据线P3.7-3.1口设为推挽方式
//        P2MDOUT = 0xe0;                     // 控制线P2.7-2.5口设为推挽方式
//     (4)LCM初始化步骤,使用时根据需要选择;
//     (5)读BF/AC函数和读LCM数据函数一般很少用到,这里不编写;
//-----------------------------------------------------------------

//-----------------------------------------------------------------
// 头文件包含
//-----------------------------------------------------------------
#include <c8051f020.h>
#include <intrins.h>
#include "CharLCD.h"
#include "delay.h"

//-----------------------------------------------------------------
// LCM的CGRAM数据定义
//-----------------------------------------------------------------
// 字符码即是CGROM的地址
uchar code CGTab[64]={
	0x08,0x0F,0x12,0x0F,0x0A,0x1F,0x02,0x02,//"年"字符码=00H或08H
   0x0F,0x09,0x0F,0x09,0x0F,0x09,0x11,0x00,//"月"字符码=01H或09H
   0x1F,0x11,0x11,0x1F,0x11,0x11,0x1F,0x00,//"日"字符码=02H或0AH
   0x11,0x0A,0x04,0x1F,0x04,0x1F,0x04,0x00,//"￥"字符码=03H或0BH
   0x0E,0x00,0x1F,0x0A,0x0A,0x0A,0x13,0x00,//"元"字符码=04H或0CH
   0x18,0x18,0x07,0x08,0x08,0x08,0x07,0x00,//"℃"字符码=05H或0DH
   0x0F,0x0F,0x0F,0x0A,0x0F,0x12,0x07,0x1F,//"星"字符码=06H或0EH
   0x00,0x00,0x0E,0x00,0x00,0x1F,0x00,0x00 //"二"字符码=07H或0FH
	};
// 0x04,0x04,0x04,0x07,0x04,0x04,0x1f,0x00,//"上"字符码
// 0x1f,0x04,0x04,0x06,0x05,0x04,0x04,0x00,//"下"字符码=07H

//-----------------------------------------------------------------
// 全局变量:内RAM存储单元定义
//-----------------------------------------------------------------
uchar lcdbuff;
uchar lcdbuff_1;
/**
uchar bdata lcdbuff;							// LCM命令/数据暂存单元,允许位操作
sbit lcdbuff7=lcdbuff^7;					// 没有定义,不可在.c文件中直接使用位赋值
sbit lcdbuff6=lcdbuff^6;
sbit lcdbuff5=lcdbuff^5;
sbit lcdbuff4=lcdbuff^4;
sbit lcdbuff3=lcdbuff^3;
sbit lcdbuff2=lcdbuff^2;
sbit lcdbuff1=lcdbuff^1;
sbit lcdbuff0=lcdbuff^0;
/**/

//-----------------------------------------------------------------
// 函数声明
//-----------------------------------------------------------------
//void Wr_CodeData (void);               // 写操作共同部分程序
//void Delay_10us (unsigned char t);		// 延时时基:10us

//-----------------------------------------------------------------
// 初始化程序区
//-----------------------------------------------------------------

//-----------------------------------------------------------------
// void LCM_Init (void)
//-----------------------------------------------------------------
//
// 函数功能: LCM初始化
// 入口参数: 无
// 返回参数: 无
// 全局变量: 无
// 调用模块: WrCLcdC(uchar);CG_Write()     
// 注意事项: 
//     (1)具体流程查看HD44780(KS0066)的中文数据手册;
//     (2)因5V的液晶模块在3.3V电压工作的C8051单片机中应用,而其接口未
//        接上拉电阻,所以需要多次(大于4次)对功能设置进行初始化才能液晶模块正常工作
//-----------------------------------------------------------------
void LCM_Init (void)
{
	uchar i;

	for (i=5; i>0; i--)
	{
		WrCLcdC(0x28);						   	// LCM功能设置:4位数据接口,2行5*7显示
  }
	WrCLcdC(0x01);						      // LCM清屏
	WrCLcdC(0x06);						      // LCM输入方式设置:读写操作后AC自增1
	WrCLcdC(0x0F);						      // LCM显示控制设置:开,光标和闪烁显示
	WrCLcdC(0x0C);						      // LCM显示控制设置:开显示
	CG_Write();							      	// LCM自定义字符库
}

//-----------------------------------------------------------------
// 功能程序区
//-----------------------------------------------------------------

//-----------------------------------------------------------------
// void WrCLcdC (uchar lcdcomm)
//-----------------------------------------------------------------
//
// 函数功能: 写LCM的指令代码
// 入口参数: LCM指令
// 返回参数: 无
// 全局变量: lcdbuff:LCM命令/数据暂存单元,允许位操作
// 调用模块: Wr_CodeData()     
// 注意事项:
//-----------------------------------------------------------------
void WrCLcdC (uchar lcdcomm)
{
  lcdbuff = lcdcomm;
	lcdbuff_1 = lcdcomm;
	RS_clr;                             // RS=0,RW=0,E=1-0:允许写
	RW_clr;
	Wr_CodeData();                      // 写入LCM指令                             
}

//-----------------------------------------------------------------
// void WrCLcdD (uchar lcddata)
//-----------------------------------------------------------------
//
// 函数功能: 写LCM要显示的数据
// 入口参数: 待写的数据
// 返回参数: 无
// 全局变量: lcdbuff:LCM命令/数据暂存单元,允许位操作
// 调用模块: Wr_CodeData()     
// 注意事项:
//-----------------------------------------------------------------
void WrCLcdD (uchar lcddata)
{
  lcdbuff = lcddata;
	lcdbuff_1 = lcddata;
	RS_set;                             // RS=1,RW=0,E=1-0:允许写
	RW_clr;	
	Wr_CodeData();
}


//-----------------------------------------------------------------
// void WriteString (uchar x, uchar y, uchar *s)
//-----------------------------------------------------------------
//
// 函数功能: 指定位置显示一串字符串
// 入口参数: x:行, y:列, *s:字符指针
// 返回参数: 无
// 全局变量: 无
// 调用模块: WrCLcdC(uchar);WrCLcdD(uchar)     
// 注意事项: x的值只能为1或2, y≤16
//-----------------------------------------------------------------
void WriteString (uchar x, uchar y, uchar *s)          
{
	// 设置LCM显示DDRAM起始地址
  if (x == 1)
		WrCLcdC(0x80+y-0x01);								// 第一行
	else 
		WrCLcdC(0xc0+y-0x01);								// 第二行
	// 显示字符串					      	
	for ( ; *s != '\0'; s ++)
	{
		WrCLcdD (*s);	
	}	
}

// 写操作共同部分程序
void Wr_CodeData (void)
{
	DLCD &= 0x0f;                    		// 清高四位
	lcdbuff &= 0xf0;                    // 清低四位
	DLCD |= lcdbuff;
	E_set;                            	// E高低电平时间最少为450ns
	_nop_();
	Delay_ns(2);
	E_clr;
	_nop_();
	Delay_ns(2);
	DLCD &= 0x0f;                    		// 清高四位
	lcdbuff = (lcdbuff_1 << 4);         // 左移四位
	lcdbuff &= 0xf0;                    // 清低四位
	DLCD |= lcdbuff;
	E_set;                             	// E高低电平时间最少为450ns
	_nop_();
	Delay_ns(2);
	E_clr;
	E_clr;
	Delay_10us(200);
}

//-----------------------------------------------------------------
// void CG_Write (void)
//-----------------------------------------------------------------
//
// 函数功能: 将自定义的字符送到CGRAM,以便使用时调用
// 入口参数: 无
// 返回参数: 无
// 全局变量: 无
// 调用模块: WrCLcdC(uchar);WrCLcdD(uchar)     
// 注意事项: 
//-----------------------------------------------------------------
/**/
void CG_Write (void)
{
	uchar i;

	WrCLcdC(0x40);						      		// 设置LCM的CGRAM首地址
	for (i=0; i<64; i++)                // 共设置8个5*8字符
	{
		WrCLcdD(CGTab[i]);
	}
}
/**/

//-----------------------------------------------------------------
// void WrCLcd_char_num (uchar x, uchar y, uchar uchar_num)
//-----------------------------------------------------------------
//
// 函数功能: 显示十进制无符号字符数据
// 入口参数: x:行, y:列, uchar_num:无符号字符型数据
// 返回参数: 无
// 全局变量: 无
// 调用模块: WrCLcdC(uchar);WrCLcdD(uchar)     
// 注意事项: 显示数据格式为左对齐方式; x的值只能为1或2, y≤16
//-----------------------------------------------------------------
//void WrCLcd_char_num (uchar x, uchar y, uchar uchar_num)
//{
//	bit   zc_flag;  														// 高位为零标志
//	uchar i;
//	uchar date_bufc[4] = {"    "};	 						// 缓存数组

//	zc_flag = 0;  															// ‘1’：电平表示已经有非零数据出现过

//	// 设置LCM显示DDRAM起始地址
//  if (x == 1)
//		WrCLcdC(0x80+y-0x01);								// 第一行
//	else 
//		WrCLcdC(0xc0+y-0x01);								// 第二行
//	// 显示数据	 								
//	if (uchar_num != 0)
//	{
//		date_bufc[0] = ((uchar_num % 1000) / 100) + 48;	// 取出数据最高位
//		date_bufc[1] = ((uchar_num % 100) / 10) + 48;
//		date_bufc[2] = (uchar_num % 10) + 48;						// 取出数据最低位
//	
//		for (i = 0; i < 3; i ++)
//		{
//			if ((date_bufc[i] != '0') && (zc_flag == 0))
//			{
//				zc_flag = 1;
//			}
//			if (zc_flag == 1)
//			{
//				WrCLcdD(date_bufc[i]);
//			}
//		}
//	}
//	else 
//	{
//		WrCLcdD('0');
//	}
//}

//-----------------------------------------------------------------
// void WrCLcd_int_num (uchar x, uchar y, uint  uint_num)
//-----------------------------------------------------------------
//
// 函数功能: 显示十进制无符号整型数据
// 入口参数: x:行, y:列, uchar_num:无符号整型数据
// 返回参数: 无
// 全局变量: 无
// 调用模块: WrCLcdC(uchar);WrCLcdD(uchar)     
// 注意事项: 显示数据格式为左对齐方式; x的值只能为1或2, y≤16
//-----------------------------------------------------------------
//void WrCLcd_int_num (uchar x, uchar y, uint  uint_num)
//{
//	bit   zi_flag;  												// 高位为零标志
//	uchar i;
//	uchar date_bufi[6] = {"      "};	 			// 缓存数组

//	zi_flag = 0;  										 			// ‘1’：电平表示已经有非零数据出现过

//	// 设置LCM显示DDRAM起始地址
//  if (x == 1)
//		WrCLcdC(0x80+y-0x01);									// 第一行
//	else 
//		WrCLcdC(0xc0+y-0x01);									// 第二行
//	// 显示数据	 								
//	if (uint_num != 0)
//	{
//		date_bufi[0] = ((uint_num % 100000) / 10000) + 48;	// 取出数据最高位
//		date_bufi[1] = ((uint_num % 10000) / 1000) + 48;		// 
//		date_bufi[2] = ((uint_num % 1000) / 100) + 48;			// 
//		date_bufi[3] = ((uint_num % 100) / 10) + 48;				// 
//		date_bufi[4] =  (uint_num % 10) + 48;								// 取出数据最低位
//	
//		for (i = 0; i < 5; i ++)
//		{
//			if ((date_bufi[i] != '0') && (zi_flag == 0))
//			{
//				zi_flag = 1;
//			}
//			if (zi_flag == 1)
//			{
//				WrCLcdD(date_bufi[i]);
//			}
//		}
//	}
//	else 
//	{
//		WrCLcdD('0');
//	}
//}

//-----------------------------------------------------------------
// void WrCLcd_long_num (uchar x, uchar y, unsigned long ulong_num)
//-----------------------------------------------------------------
//
// 函数功能: 显示十进制无符号长整型数据
// 入口参数: x:行, y:列, uchar_num:无符号长整形数据
// 返回参数: 无
// 全局变量: 无
// 调用模块: WrCLcdC(uchar);WrCLcdD(uchar)     
// 注意事项: 显示数据格式为左对齐方式; x的值只能为1或2, y≤16
//-----------------------------------------------------------------
void WrCLcd_long_num (uchar x, uchar y, unsigned long ulong_num)
{	bit   zl_flag;  															// 高位为零标志
	uchar i;
	uchar date_bufl[11] = {"           "}; 				// 缓存数组

	zl_flag = 0;  																// ‘1’：电平表示已经有非零数据出现过

	// 设置LCM显示DDRAM起始地址
  if (x == 1)
		WrCLcdC(0x80+y-0x01);									// 第一行
	else 
		WrCLcdC(0xc0+y-0x01);									// 第二行
	// 显示数据	 								
	if (ulong_num != 0)
	{
		date_bufl[0] = ((ulong_num % 10000000000) / 1000000000) + 48;	// 取出数据最高位
		date_bufl[1] = ((ulong_num % 1000000000) / 100000000) + 48;		// 取出数据最高位
		date_bufl[2] = ((ulong_num % 100000000) / 10000000) + 48;			// 
		date_bufl[3] = ((ulong_num % 10000000) / 1000000) + 48;				// 
		date_bufl[4] = ((ulong_num % 1000000) / 100000) + 48;					// 
		date_bufl[5] = ((ulong_num % 100000) / 10000) + 48;						// 
		date_bufl[6] = ((ulong_num % 10000) / 1000) + 48;							// 
		date_bufl[7] = ((ulong_num % 1000) / 100) + 48;								// 
		date_bufl[8] = ((ulong_num % 100) / 10) + 48;									// 
		date_bufl[9] =  (ulong_num % 10) + 48;												// 取出数据最低位
	
		for (i = 0; i < 10; i ++)
		{
			if ((date_bufl[i] != '0') && (zl_flag == 0))
			{
				zl_flag = 1;
			}
			if (zl_flag == 1)
			{
				WrCLcdD(date_bufl[i]);
			}
		}
	}
	else 
	{
		WrCLcdD('0');
	}
}

//-----------------------------------------------------------------------------
// End Of File
//-----------------------------------------------------------------------------